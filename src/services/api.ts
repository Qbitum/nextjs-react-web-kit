/* tslint:disable */
/* eslint-disable */
/**
 * Label Inspector APIs
 * This is a first set of label inspector services apis.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';
import { Key } from 'react';

/**
 * 
 * @export
 * @interface AddJobRequest
 */
export interface AddJobRequest {
    /**
     * 
     * @type {string}
     * @memberof AddJobRequest
     */
    'jobNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddJobRequest
     */
    'buyer'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddJobRequest
     */
    'po'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddJobRequest
     */
    'customerStyle'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddJobRequest
     */
    'labelCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddJobRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {Array<Resource>}
     * @memberof AddJobRequest
     */
    'resources'?: Array<Resource>;
}
/**
 * 
 * @export
 * @interface AddMasterDataRequest
 */
export interface AddMasterDataRequest {
    /**
     * 
     * @type {string}
     * @memberof AddMasterDataRequest
     */
    'masterDataType'?: AddMasterDataRequestMasterDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AddMasterDataRequest
     */
    'masterDataName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddMasterDataRequest
     */
    'icon'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddMasterDataRequest
     */
    'tenantId'?: number;
}

export const AddMasterDataRequestMasterDataTypeEnum = {
    Buyers: 'buyers',
    LabelCategories: 'labelCategories',
    QcStations: 'qcStations',
    QcTypes: 'qcTypes'
} as const;

export type AddMasterDataRequestMasterDataTypeEnum = typeof AddMasterDataRequestMasterDataTypeEnum[keyof typeof AddMasterDataRequestMasterDataTypeEnum];

/**
 * 
 * @export
 * @interface AddTenantRequest
 */
export interface AddTenantRequest {
    /**
     * 
     * @type {string}
     * @memberof AddTenantRequest
     */
    'tenantName'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'reference': string;
}
/**
 * 
 * @export
 * @interface DataItem
 */
export interface DataItem {
    /**
     * 
     * @type {string}
     * @memberof DataItem
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof DataItem
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DataItem
     */
    'icon'?: string;
}
/**
 * 
 * @export
 * @interface DataResposne
 */
export interface DataResposne {
    /**
     * 
     * @type {string}
     * @memberof DataResposne
     */
    'message'?: string;
    /**
     * 
     * @type {Array<DataItem>}
     * @memberof DataResposne
     */
    'data': Array<DataItem>;
}
/**
 * 
 * @export
 * @interface DeleteFileResponse
 */
export interface DeleteFileResponse {
    /**
     * 
     * @type {string}
     * @memberof DeleteFileResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteFileResponse
     */
    'resourceId'?: string;
}
/**
 * 
 * @export
 * @interface FileUpdateResponse
 */
export interface FileUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof FileUpdateResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUpdateResponse
     */
    'resourceId'?: string;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'resourceId'?: string;
}
/**
 * 
 * @export
 * @interface GetInferenceResultRequest
 */
export interface GetInferenceResultRequest {
    /**
     * 
     * @type {string}
     * @memberof GetInferenceResultRequest
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInferenceResultRequest
     */
    'jobId'?: string;
}
/**
 * 
 * @export
 * @interface Inference
 */
export interface Inference {
    /**
     * 
     * @type {string}
     * @memberof Inference
     */
    'resourceId': string;
    /**
     * 
     * @type {number}
     * @memberof Inference
     */
    'numberOfDefects': number;
    /**
     * 
     * @type {string}
     * @memberof Inference
     */
    'status'?: InferenceStatusEnum;
}

export const InferenceStatusEnum = {
    Running: 'RUNNING',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED'
} as const;

export type InferenceStatusEnum = typeof InferenceStatusEnum[keyof typeof InferenceStatusEnum];

/**
 * 
 * @export
 * @interface InferenceRequest
 */
export interface InferenceRequest {
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'jobId': string;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'inspectionType': InferenceRequestInspectionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'referenceResourceId': string;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'pageNumber': string;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'operatorId': string;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'cropDimResourceId': string;
    /**
     * 
     * @type {string}
     * @memberof InferenceRequest
     */
    'imgDimResourceId': string;
}

export const InferenceRequestInspectionTypeEnum = {
    Sample: 'SAMPLE',
    Actual: 'ACTUAL'
} as const;

export type InferenceRequestInspectionTypeEnum = typeof InferenceRequestInspectionTypeEnum[keyof typeof InferenceRequestInspectionTypeEnum];

/**
 * 
 * @export
 * @interface InferenceResult
 */
export interface InferenceResult {
    /**
     * Unique identifier for the image
     * @type {string}
     * @memberof InferenceResult
     */
    'resultImage'?: string;
    /**
     * Number of defects found in the image
     * @type {number}
     * @memberof InferenceResult
     */
    'noOfDefects'?: number;
    /**
     * Expected number of defects in the image
     * @type {number}
     * @memberof InferenceResult
     */
    'expectedDefects'?: number;
}
/**
 * 
 * @export
 * @interface Inspection
 */
export interface Inspection {
    /**
     * 
     * @type {string}
     * @memberof Inspection
     */
    'labelName': string;
    /**
     * 
     * @type {string}
     * @memberof Inspection
     */
    'sourceImageId': string;
    /**
     * 
     * @type {string}
     * @memberof Inspection
     */
    'jobId': string;
    /**
     * 
     * @type {string}
     * @memberof Inspection
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof Inspection
     */
    'resourceId': string;
    /**
     * 
     * @type {number}
     * @memberof Inspection
     */
    'createAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof Inspection
     */
    'status': InspectionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Inspection
     */
    'inspectionType': InspectionInspectionTypeEnum;
    /**
     * 
     * @type {InferenceResult}
     * @memberof Inspection
     */
    'result'?: InferenceResult;
}

export const InspectionStatusEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Initiated: 'INITIATED'
} as const;

export type InspectionStatusEnum = typeof InspectionStatusEnum[keyof typeof InspectionStatusEnum];
export const InspectionInspectionTypeEnum = {
    Actual: 'ACTUAL',
    Sample: 'SAMPLE'
} as const;

export type InspectionInspectionTypeEnum = typeof InspectionInspectionTypeEnum[keyof typeof InspectionInspectionTypeEnum];

/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'jobId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'jobNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'buyer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'po'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'customerStyle'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'progressStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'createdDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'labelCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'status'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Job
     */
    'approved'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'numberOfSourceImages'?: number;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'userId'?: string;
    /**
     * 
     * @type {MetaData}
     * @memberof Job
     */
    'metaData'?: MetaData;
    /**
     * 
     * @type {Array<Resource>}
     * @memberof Job
     */
    'resources'?: Array<Resource>;
}
/**
 * 
 * @export
 * @interface MetaData
 */
export interface MetaData {
    /**
     * 
     * @type {number}
     * @memberof MetaData
     */
    'maskHeight'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaData
     */
    'maskWidth'?: number;
    /**
     * 
     * @type {Array<Resource>}
     * @memberof MetaData
     */
    'pages'?: Array<Resource>;
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'modelKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'cropDimResourceId'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Overview
 */
export interface Overview {
    jobNumber: string;
    addedDate: string | number | Date;
    buyer: string;
    jobId: Key | null | undefined;
    /**
     * 
     * @type {string}
     * @memberof Overview
     */
    'jobStatus': string;
    /**
     * 
     * @type {number}
     * @memberof Overview
     */
    'totalNoOfJobs': number;
}
/**
 * 
 * @export
 * @interface PageReference
 */
export interface PageReference {
    /**
     * 
     * @type {string}
     * @memberof PageReference
     */
    'pageName'?: string;
    /**
     * 
     * @type {Array<Sample>}
     * @memberof PageReference
     */
    'samples'?: Array<Sample>;
}
/**
 * 
 * @export
 * @interface PipelineTriggerResponse
 */
export interface PipelineTriggerResponse {
    /**
     * 
     * @type {string}
     * @memberof PipelineTriggerResponse
     */
    'status': PipelineTriggerResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PipelineTriggerResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PipelineTriggerResponse
     */
    'reference': string;
}

export const PipelineTriggerResponseStatusEnum = {
    Pending: 'PENDING'
} as const;

export type PipelineTriggerResponseStatusEnum = typeof PipelineTriggerResponseStatusEnum[keyof typeof PipelineTriggerResponseStatusEnum];

/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Resource
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'cropDimResourceId': string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    'imgDimResourceId': string;
}
/**
 * 
 * @export
 * @interface Sample
 */
export interface Sample {
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'resourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sample
     */
    'sampleName'?: string;
}
/**
 * 
 * @export
 * @interface SampleGenerationRequest
 */
export interface SampleGenerationRequest {
    /**
     * 
     * @type {string}
     * @memberof SampleGenerationRequest
     */
    'jobId': string;
    /**
     * 
     * @type {Array<SourceImage>}
     * @memberof SampleGenerationRequest
     */
    'sourceImages': Array<SourceImage>;
}
/**
 * 
 * @export
 * @interface SampleGenerationResponse
 */
export interface SampleGenerationResponse {
    /**
     * 
     * @type {string}
     * @memberof SampleGenerationResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PageReference>}
     * @memberof SampleGenerationResponse
     */
    'pageReferences'?: Array<PageReference>;
}
/**
 * 
 * @export
 * @interface SampleSessionSearchRequest
 */
export interface SampleSessionSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SampleSessionSearchRequest
     */
    'jobId': string;
    /**
     * 
     * @type {number}
     * @memberof SampleSessionSearchRequest
     */
    'startDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SampleSessionSearchRequest
     */
    'endDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof SampleSessionSearchRequest
     */
    'inspectionType'?: SampleSessionSearchRequestInspectionTypeEnum;
}

export const SampleSessionSearchRequestInspectionTypeEnum = {
    Actual: 'ACTUAL',
    Sample: 'SAMPLE'
} as const;

export type SampleSessionSearchRequestInspectionTypeEnum = typeof SampleSessionSearchRequestInspectionTypeEnum[keyof typeof SampleSessionSearchRequestInspectionTypeEnum];

/**
 * 
 * @export
 * @interface SamplesRequest
 */
export interface SamplesRequest {
    /**
     * 
     * @type {number}
     * @memberof SamplesRequest
     */
    'qty': number;
    /**
     * 
     * @type {string}
     * @memberof SamplesRequest
     */
    'jobId': string;
}
/**
 * 
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    'jobProgressStatus': SearchRequestJobProgressStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    'pageNumber': number;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    'jobStatus': SearchRequestJobStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    'addedDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    'JobNo'?: string;
}

export const SearchRequestJobProgressStatusEnum = {
    InProgress: 'IN-PROGRESS',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type SearchRequestJobProgressStatusEnum = typeof SearchRequestJobProgressStatusEnum[keyof typeof SearchRequestJobProgressStatusEnum];
export const SearchRequestJobStatusEnum = {
    All: 'All',
    ReadyToProcess: 'Ready to process',
    Processing: 'Processing',
    PendingApproval: 'Pending approval',
    ProcessFailed: 'Process failed'
} as const;

export type SearchRequestJobStatusEnum = typeof SearchRequestJobStatusEnum[keyof typeof SearchRequestJobStatusEnum];

/**
 * 
 * @export
 * @interface SearchResponse
 */
export interface SearchResponse {
    /**
     * 
     * @type {string}
     * @memberof SearchResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResponse
     */
    'message'?: string;
    /**
     * 
     * @type {SearchResponseData}
     * @memberof SearchResponse
     */
    'data'?: SearchResponseData;
}
/**
 * 
 * @export
 * @interface SearchResponseData
 */
export interface SearchResponseData {
    /**
     * 
     * @type {number}
     * @memberof SearchResponseData
     */
    'numberOfPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchResponseData
     */
    'currentPageNumber'?: number;
    /**
     * 
     * @type {Array<TrainingJob>}
     * @memberof SearchResponseData
     */
    'rows'?: Array<TrainingJob>;
}
/**
 * 
 * @export
 * @interface Segementations
 */
export interface Segementations {
    /**
     * 
     * @type {string}
     * @memberof Segementations
     */
    'referenceId': string;
    /**
     * 
     * @type {Array<Resource>}
     * @memberof Segementations
     */
    'resources': Array<Resource>;
}
/**
 * 
 * @export
 * @interface SegmentArtworkRequest
 */
export interface SegmentArtworkRequest {
    /**
     * 
     * @type {string}
     * @memberof SegmentArtworkRequest
     */
    'resourceId': string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'createdAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'modifiedAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'status'?: SessionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'jobId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'stationId'?: string;
    /**
     * 
     * @type {Array<Inspection>}
     * @memberof Session
     */
    'inspections'?: Array<Inspection>;
}

export const SessionStatusEnum = {
    Started: 'STARTED',
    Paused: 'PAUSED',
    Completed: 'COMPLETED'
} as const;

export type SessionStatusEnum = typeof SessionStatusEnum[keyof typeof SessionStatusEnum];

/**
 * 
 * @export
 * @interface SessionRequest
 */
export interface SessionRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    'jobId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    'stationId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    'qcType': string;
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    'status': SessionRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    'po'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    'sessionType': SessionRequestSessionTypeEnum;
}

export const SessionRequestStatusEnum = {
    Started: 'STARTED',
    Paused: 'PAUSED',
    Completed: 'COMPLETED'
} as const;

export type SessionRequestStatusEnum = typeof SessionRequestStatusEnum[keyof typeof SessionRequestStatusEnum];
export const SessionRequestSessionTypeEnum = {
    Actual: 'ACTUAL',
    Sample: 'SAMPLE'
} as const;

export type SessionRequestSessionTypeEnum = typeof SessionRequestSessionTypeEnum[keyof typeof SessionRequestSessionTypeEnum];

/**
 * 
 * @export
 * @interface SessionSearchRequest
 */
export interface SessionSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionSearchRequest
     */
    'jobId': string;
    /**
     * 
     * @type {number}
     * @memberof SessionSearchRequest
     */
    'startDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SessionSearchRequest
     */
    'endDate'?: number;
}
/**
 * 
 * @export
 * @interface SessionSearchResponse
 */
export interface SessionSearchResponse {
    /**
     * 
     * @type {string}
     * @memberof SessionSearchResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionSearchResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Session>}
     * @memberof SessionSearchResponse
     */
    'data'?: Array<Session>;
}
/**
 * 
 * @export
 * @interface SessionUpdateRequest
 */
export interface SessionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionUpdateRequest
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof SessionUpdateRequest
     */
    'status'?: SessionUpdateRequestStatusEnum;
}

export const SessionUpdateRequestStatusEnum = {
    Started: 'STARTED',
    Paused: 'PAUSED',
    Completed: 'COMPLETED'
} as const;

export type SessionUpdateRequestStatusEnum = typeof SessionUpdateRequestStatusEnum[keyof typeof SessionUpdateRequestStatusEnum];

/**
 * 
 * @export
 * @interface SourceImage
 */
export interface SourceImage {
    /**
     * 
     * @type {string}
     * @memberof SourceImage
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof SourceImage
     */
    'sampleName': string;
}
/**
 * 
 * @export
 * @interface SourceImagesInner
 */
export interface SourceImagesInner {
    /**
     * source image path
     * @type {string}
     * @memberof SourceImagesInner
     */
    'resourcePath'?: string;
    /**
     * label name of the source image
     * @type {string}
     * @memberof SourceImagesInner
     */
    'resourceName'?: string;
}
/**
 * 
 * @export
 * @interface Summary
 */
export interface Summary {
    /**
     * 
     * @type {string}
     * @memberof Summary
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Summary
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Overview>}
     * @memberof Summary
     */
    'data'?: Array<Overview>;
}
/**
 * 
 * @export
 * @interface TrainingJob
 */
export interface TrainingJob {
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'jobId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TrainingJob
     */
    'addedDate'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrainingJob
     */
    'modifiedDate'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'jobNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'buyer'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'style'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'labelCategory'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'jobProgressStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'jobStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'labelId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrainingJob
     */
    'actions'?: Array<string>;
    /**
     * 
     * @type {MetaData}
     * @memberof TrainingJob
     */
    'metaData'?: MetaData;
    /**
     * 
     * @type {string}
     * @memberof TrainingJob
     */
    'po'?: string;
}

/**
 * FileuploadServiceApi - axios parameter creator
 * @export
 */
export const FileuploadServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('deleteFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('deleteFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('downloadFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('downloadFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {File} [file] 
         * @param {string} [fileType] 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('updateFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }

            if (fileType !== undefined) {
                localVarFormParams.append('fileType', fileType as any);
            }

            if (resourceName !== undefined) {
                localVarFormParams.append('resourceName', resourceName as any);
            }

            if (resourceId !== undefined) {
                localVarFormParams.append('resourceId', resourceId as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('uploadFile', 'xClientId', xClientId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('uploadFile', 'resourceName', resourceName)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('uploadFile', 'fileType', fileType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('uploadFile', 'clientId', clientId)
            // verify required parameter 'uploadedDevice' is not null or undefined
            assertParamExists('uploadFile', 'uploadedDevice', uploadedDevice)
            const localVarPath = `/v1/resources/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }

            if (resourceName !== undefined) {
                localVarFormParams.append('resourceName', resourceName as any);
            }

            if (fileType !== undefined) {
                localVarFormParams.append('fileType', fileType as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.append('clientId', clientId as any);
            }

            if (uploadedDevice !== undefined) {
                localVarFormParams.append('uploadedDevice', uploadedDevice as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('viewFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('viewFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileuploadServiceApi - functional programming interface
 * @export
 */
export const FileuploadServiceApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = FileuploadServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {File} [file] 
         * @param {string} [fileType] 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(xClientId, resourceId, authorization, file, fileType, resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileuploadServiceApi - factory interface
 * @export
 */
export const FileuploadServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileuploadServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<DeleteFileResponse> {
            return localVarFp.deleteFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {File} [file] 
         * @param {string} [fileType] 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options?: any): AxiosPromise<FileUpdateResponse> {
            return localVarFp.updateFile(xClientId, resourceId, authorization, file, fileType, resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: any): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.viewFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileuploadServiceApi - object-oriented interface
 * @export
 * @class FileuploadServiceApi
 * @extends {BaseAPI}
 */
export class FileuploadServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileuploadServiceApi
     */
    public deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return FileuploadServiceApiFp(this.configuration).deleteFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId Client id
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileuploadServiceApi
     */
    public downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return FileuploadServiceApiFp(this.configuration).downloadFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {File} [file] 
     * @param {string} [fileType] 
     * @param {string} [resourceName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileuploadServiceApi
     */
    public updateFile(xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options?: AxiosRequestConfig) {
        return FileuploadServiceApiFp(this.configuration).updateFile(xClientId, resourceId, authorization, file, fileType, resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {File} file 
     * @param {string} resourceName 
     * @param {string} fileType 
     * @param {string} clientId 
     * @param {string} uploadedDevice 
     * @param {string} [authorization] Authorization Bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileuploadServiceApi
     */
    public uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: AxiosRequestConfig) {
        return FileuploadServiceApiFp(this.configuration).uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId Client id
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileuploadServiceApi
     */
    public viewFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return FileuploadServiceApiFp(this.configuration).viewFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MobileApi - axios parameter creator
 * @export
 */
export const MobileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterData: async (xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addMasterData', 'xClientId', xClientId)
            const localVarPath = `/v1/tenant/training/msdata/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addMasterDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * adding new inspection (page) to a session
         * @summary add new inspection
         * @param {string} xClientId client ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewInspection: async (xClientId: string, inspection: Inspection, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addNewInspection', 'xClientId', xClientId)
            // verify required parameter 'inspection' is not null or undefined
            assertParamExists('addNewInspection', 'inspection', inspection)
            const localVarPath = `/v1/sessions/inspection/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inspection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTenant: async (xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addTenant', 'xClientId', xClientId)
            const localVarPath = `/v1/tenant/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addTenantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInferenceStatus: async (xClientId: string, referenceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('checkInferenceStatus', 'xClientId', xClientId)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('checkInferenceStatus', 'referenceId', referenceId)
            const localVarPath = `/v1/sessions/inference/status/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} referenceId runId of inference pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkV3InferenceStatus: async (xClientId: string, authorization: string, referenceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('checkV3InferenceStatus', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('checkV3InferenceStatus', 'authorization', authorization)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('checkV3InferenceStatus', 'referenceId', referenceId)
            const localVarPath = `/v3/sessions/inference/status/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * adding new session to a job
         * @summary add new session
         * @param {string} xClientId client ID
         * @param {SessionRequest} sessionRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSession: async (xClientId: string, sessionRequest: SessionRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('createNewSession', 'xClientId', xClientId)
            // verify required parameter 'sessionRequest' is not null or undefined
            assertParamExists('createNewSession', 'sessionRequest', sessionRequest)
            const localVarPath = `/v1/sessions/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('deleteFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('deleteFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('downloadFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('downloadFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * end a session after inspections
         * @summary end a session
         * @param {string} xClientId client ID
         * @param {SessionUpdateRequest} sessionUpdateRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endSession: async (xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('endSession', 'xClientId', xClientId)
            // verify required parameter 'sessionUpdateRequest' is not null or undefined
            assertParamExists('endSession', 'sessionUpdateRequest', sessionUpdateRequest)
            const localVarPath = `/v1/sessions/update/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sessionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getJobById', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobById', 'jobId', jobId)
            const localVarPath = `/v1/training/job/view/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterData: async (xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getMasterData', 'xClientId', xClientId)
            // verify required parameter 'mtype' is not null or undefined
            assertParamExists('getMasterData', 'mtype', mtype)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMasterData', 'tenantId', tenantId)
            const localVarPath = `/v1/tenant/training/msdata/{mtype}`
                .replace(`{${"mtype"}}`, encodeURIComponent(String(mtype)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateInference: async (xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('initiateInference', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('initiateInference', 'authorization', authorization)
            // verify required parameter 'inferenceRequest' is not null or undefined
            assertParamExists('initiateInference', 'inferenceRequest', inferenceRequest)
            const localVarPath = `/v1/sessions/inference/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateV3Inference: async (xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('initiateV3Inference', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('initiateV3Inference', 'authorization', authorization)
            // verify required parameter 'inferenceRequest' is not null or undefined
            assertParamExists('initiateV3Inference', 'inferenceRequest', inferenceRequest)
            const localVarPath = `/v3/sessions/inference/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobs: async (xClientId: string, authorization?: string, searchRequest?: SearchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('searchJobs', 'xClientId', xClientId)
            const localVarPath = `/v1/training/jobs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search sessions for given search criteria
         * @summary search sessions
         * @param {string} xClientId client ID
         * @param {SessionSearchRequest} sessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSessions: async (xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('searchSessions', 'xClientId', xClientId)
            // verify required parameter 'sessionSearchRequest' is not null or undefined
            assertParamExists('searchSessions', 'sessionSearchRequest', sessionSearchRequest)
            const localVarPath = `/v1/sessions/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sessionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update inspection with a result
         * @summary update inspection
         * @param {string} xClientId client ID
         * @param {string} inspectionId inspection ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInspection: async (xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateInspection', 'xClientId', xClientId)
            // verify required parameter 'inspectionId' is not null or undefined
            assertParamExists('updateInspection', 'inspectionId', inspectionId)
            // verify required parameter 'inspection' is not null or undefined
            assertParamExists('updateInspection', 'inspection', inspection)
            const localVarPath = `/v1/sessions/inspection/update/{inspectionId}`
                .replace(`{${"inspectionId"}}`, encodeURIComponent(String(inspectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inspection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('uploadFile', 'xClientId', xClientId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('uploadFile', 'resourceName', resourceName)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('uploadFile', 'fileType', fileType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('uploadFile', 'clientId', clientId)
            // verify required parameter 'uploadedDevice' is not null or undefined
            assertParamExists('uploadFile', 'uploadedDevice', uploadedDevice)
            const localVarPath = `/v1/resources/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }

            if (resourceName !== undefined) {
                localVarFormParams.append('resourceName', resourceName as any);
            }

            if (fileType !== undefined) {
                localVarFormParams.append('fileType', fileType as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.append('clientId', clientId as any);
            }

            if (uploadedDevice !== undefined) {
                localVarFormParams.append('uploadedDevice', uploadedDevice as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('viewFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('viewFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileApi - functional programming interface
 * @export
 */
export const MobileApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileApiAxiosParamCreator(configuration)
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMasterData(xClientId, authorization, addMasterDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * adding new inspection (page) to a session
         * @summary add new inspection
         * @param {string} xClientId client ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewInspection(xClientId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewInspection(xClientId, inspection, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTenant(xClientId, authorization, addTenantRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkInferenceStatus(xClientId: string, referenceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkInferenceStatus(xClientId, referenceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} referenceId runId of inference pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkV3InferenceStatus(xClientId: string, authorization: string, referenceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkV3InferenceStatus(xClientId, authorization, referenceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * adding new session to a job
         * @summary add new session
         * @param {string} xClientId client ID
         * @param {SessionRequest} sessionRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewSession(xClientId: string, sessionRequest: SessionRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewSession(xClientId, sessionRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * end a session after inspections
         * @summary end a session
         * @param {string} xClientId client ID
         * @param {SessionUpdateRequest} sessionUpdateRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endSession(xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endSession(xClientId, sessionUpdateRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobById(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResposne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMasterData(xClientId, mtype, tenantId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateInference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateInference(xClientId, authorization, inferenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateV3Inference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateV3Inference(xClientId, authorization, inferenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchJobs(xClientId, authorization, searchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * search sessions for given search criteria
         * @summary search sessions
         * @param {string} xClientId client ID
         * @param {SessionSearchRequest} sessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSessions(xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSessions(xClientId, sessionSearchRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update inspection with a result
         * @summary update inspection
         * @param {string} xClientId client ID
         * @param {string} inspectionId inspection ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInspection(xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInspection(xClientId, inspectionId, inspection, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MobileApi - factory interface
 * @export
 */
export const MobileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileApiFp(configuration)
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addMasterData(xClientId, authorization, addMasterDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * adding new inspection (page) to a session
         * @summary add new inspection
         * @param {string} xClientId client ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewInspection(xClientId: string, inspection: Inspection, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addNewInspection(xClientId, inspection, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addTenant(xClientId, authorization, addTenantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInferenceStatus(xClientId: string, referenceId: string, authorization?: string, options?: any): AxiosPromise<Inference> {
            return localVarFp.checkInferenceStatus(xClientId, referenceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} referenceId runId of inference pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkV3InferenceStatus(xClientId: string, authorization: string, referenceId: string, options?: any): AxiosPromise<Inference> {
            return localVarFp.checkV3InferenceStatus(xClientId, authorization, referenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * adding new session to a job
         * @summary add new session
         * @param {string} xClientId client ID
         * @param {SessionRequest} sessionRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSession(xClientId: string, sessionRequest: SessionRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.createNewSession(xClientId, sessionRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<DeleteFileResponse> {
            return localVarFp.deleteFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * end a session after inspections
         * @summary end a session
         * @param {string} xClientId client ID
         * @param {SessionUpdateRequest} sessionUpdateRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endSession(xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.endSession(xClientId, sessionUpdateRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<Job> {
            return localVarFp.getJobById(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: any): AxiosPromise<DataResposne> {
            return localVarFp.getMasterData(xClientId, mtype, tenantId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateInference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: any): AxiosPromise<PipelineTriggerResponse> {
            return localVarFp.initiateInference(xClientId, authorization, inferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateV3Inference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: any): AxiosPromise<PipelineTriggerResponse> {
            return localVarFp.initiateV3Inference(xClientId, authorization, inferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: any): AxiosPromise<SearchResponse> {
            return localVarFp.searchJobs(xClientId, authorization, searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * search sessions for given search criteria
         * @summary search sessions
         * @param {string} xClientId client ID
         * @param {SessionSearchRequest} sessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSessions(xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options?: any): AxiosPromise<SessionSearchResponse> {
            return localVarFp.searchSessions(xClientId, sessionSearchRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * update inspection with a result
         * @summary update inspection
         * @param {string} xClientId client ID
         * @param {string} inspectionId inspection ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInspection(xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateInspection(xClientId, inspectionId, inspection, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: any): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.viewFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileApi - object-oriented interface
 * @export
 * @class MobileApi
 * @extends {BaseAPI}
 */
export class MobileApi extends BaseAPI {
    /**
     * add master data
     * @summary add master data
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {AddMasterDataRequest} [addMasterDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).addMasterData(xClientId, authorization, addMasterDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * adding new inspection (page) to a session
     * @summary add new inspection
     * @param {string} xClientId client ID
     * @param {Inspection} inspection 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public addNewInspection(xClientId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).addNewInspection(xClientId, inspection, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add tenant
     * @summary add tenant
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {AddTenantRequest} [addTenantRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).addTenant(xClientId, authorization, addTenantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary check the Inference status
     * @param {string} xClientId client ID
     * @param {string} referenceId runId of inference pipeline
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public checkInferenceStatus(xClientId: string, referenceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).checkInferenceStatus(xClientId, referenceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary check the Inference status
     * @param {string} xClientId client ID
     * @param {string} authorization Bearer Token for Authorization
     * @param {string} referenceId runId of inference pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public checkV3InferenceStatus(xClientId: string, authorization: string, referenceId: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).checkV3InferenceStatus(xClientId, authorization, referenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * adding new session to a job
     * @summary add new session
     * @param {string} xClientId client ID
     * @param {SessionRequest} sessionRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public createNewSession(xClientId: string, sessionRequest: SessionRequest, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).createNewSession(xClientId, sessionRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).deleteFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId Client id
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).downloadFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * end a session after inspections
     * @summary end a session
     * @param {string} xClientId client ID
     * @param {SessionUpdateRequest} sessionUpdateRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public endSession(xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).endSession(xClientId, sessionUpdateRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} jobId jobId
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public getJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).getJobById(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary get master data
     * @param {string} xClientId client ID
     * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
     * @param {number} tenantId tenantId
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).getMasterData(xClientId, mtype, tenantId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inspect the sample against the trained AI model
     * @param {string} xClientId client ID
     * @param {string} authorization Bearer Token for Authorization
     * @param {InferenceRequest} inferenceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public initiateInference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).initiateInference(xClientId, authorization, inferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inspect the sample against the trained AI model
     * @param {string} xClientId client ID
     * @param {string} authorization Bearer Token for Authorization
     * @param {InferenceRequest} inferenceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public initiateV3Inference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).initiateV3Inference(xClientId, authorization, inferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * paginated API ,call this API in each tab
     * @summary Find jobs by status
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {SearchRequest} [searchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).searchJobs(xClientId, authorization, searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * search sessions for given search criteria
     * @summary search sessions
     * @param {string} xClientId client ID
     * @param {SessionSearchRequest} sessionSearchRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public searchSessions(xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).searchSessions(xClientId, sessionSearchRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update inspection with a result
     * @summary update inspection
     * @param {string} xClientId client ID
     * @param {string} inspectionId inspection ID
     * @param {Inspection} inspection 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public updateInspection(xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).updateInspection(xClientId, inspectionId, inspection, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {File} file 
     * @param {string} resourceName 
     * @param {string} fileType 
     * @param {string} clientId 
     * @param {string} uploadedDevice 
     * @param {string} [authorization] Authorization Bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId Client id
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public viewFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return MobileApiFp(this.configuration).viewFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * adding new inspection (page) to a session
         * @summary add new inspection
         * @param {string} xClientId client ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewInspection: async (xClientId: string, inspection: Inspection, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addNewInspection', 'xClientId', xClientId)
            // verify required parameter 'inspection' is not null or undefined
            assertParamExists('addNewInspection', 'inspection', inspection)
            const localVarPath = `/v1/sessions/inspection/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inspection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [xClientId] client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActualInferenceStatus: async (referenceId: string, xClientId?: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('checkActualInferenceStatus', 'referenceId', referenceId)
            const localVarPath = `/v2/sessions/inference/status/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInferenceStatus: async (xClientId: string, referenceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('checkInferenceStatus', 'xClientId', xClientId)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('checkInferenceStatus', 'referenceId', referenceId)
            const localVarPath = `/v1/sessions/inference/status/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} referenceId runId of inference pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkV3InferenceStatus: async (xClientId: string, authorization: string, referenceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('checkV3InferenceStatus', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('checkV3InferenceStatus', 'authorization', authorization)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('checkV3InferenceStatus', 'referenceId', referenceId)
            const localVarPath = `/v3/sessions/inference/status/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * adding new session to a job
         * @summary add new session
         * @param {string} xClientId client ID
         * @param {SessionRequest} sessionRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSession: async (xClientId: string, sessionRequest: SessionRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('createNewSession', 'xClientId', xClientId)
            // verify required parameter 'sessionRequest' is not null or undefined
            assertParamExists('createNewSession', 'sessionRequest', sessionRequest)
            const localVarPath = `/v1/sessions/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * end a session after inspections
         * @summary end a session
         * @param {string} xClientId client ID
         * @param {SessionUpdateRequest} sessionUpdateRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endSession: async (xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('endSession', 'xClientId', xClientId)
            // verify required parameter 'sessionUpdateRequest' is not null or undefined
            assertParamExists('endSession', 'sessionUpdateRequest', sessionUpdateRequest)
            const localVarPath = `/v1/sessions/update/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sessionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary generate samples
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} xClientId client ID
         * @param {SampleGenerationRequest} sampleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSamples: async (authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generateSamples', 'authorization', authorization)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generateSamples', 'xClientId', xClientId)
            // verify required parameter 'sampleGenerationRequest' is not null or undefined
            assertParamExists('generateSamples', 'sampleGenerationRequest', sampleGenerationRequest)
            const localVarPath = `/v1/sessions/generate/samples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sampleGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all inspected results of a single session
         * @summary Get all inspected results
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {GetInferenceResultRequest} getInferenceResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResult: async (xClientId: string, authorization: string, getInferenceResultRequest: GetInferenceResultRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getInferenceResult', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getInferenceResult', 'authorization', authorization)
            // verify required parameter 'getInferenceResultRequest' is not null or undefined
            assertParamExists('getInferenceResult', 'getInferenceResultRequest', getInferenceResultRequest)
            const localVarPath = `/v1/sessions/inference/result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(getInferenceResultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * inspection result for sample before the approval
         * @summary get SAMPLE inspection result
         * @param {string} xClientId client ID
         * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleInspectionResult: async (xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getSampleInspectionResult', 'xClientId', xClientId)
            // verify required parameter 'sampleSessionSearchRequest' is not null or undefined
            assertParamExists('getSampleInspectionResult', 'sampleSessionSearchRequest', sampleSessionSearchRequest)
            const localVarPath = `/v1/sessions/sample/inspections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sampleSessionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateInference: async (xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('initiateInference', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('initiateInference', 'authorization', authorization)
            // verify required parameter 'inferenceRequest' is not null or undefined
            assertParamExists('initiateInference', 'inferenceRequest', inferenceRequest)
            const localVarPath = `/v1/sessions/inference/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {InferenceRequest} inferenceRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRealInference: async (xClientId: string, inferenceRequest: InferenceRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('initiateRealInference', 'xClientId', xClientId)
            // verify required parameter 'inferenceRequest' is not null or undefined
            assertParamExists('initiateRealInference', 'inferenceRequest', inferenceRequest)
            const localVarPath = `/v2/sessions/inference/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateV3Inference: async (xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('initiateV3Inference', 'xClientId', xClientId)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('initiateV3Inference', 'authorization', authorization)
            // verify required parameter 'inferenceRequest' is not null or undefined
            assertParamExists('initiateV3Inference', 'inferenceRequest', inferenceRequest)
            const localVarPath = `/v3/sessions/inference/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * search sessions for given search criteria
         * @summary search sessions
         * @param {string} xClientId client ID
         * @param {SessionSearchRequest} sessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSessions: async (xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('searchSessions', 'xClientId', xClientId)
            // verify required parameter 'sessionSearchRequest' is not null or undefined
            assertParamExists('searchSessions', 'sessionSearchRequest', sessionSearchRequest)
            const localVarPath = `/v1/sessions/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sessionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update inspection with a result
         * @summary update inspection
         * @param {string} xClientId client ID
         * @param {string} inspectionId inspection ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInspection: async (xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateInspection', 'xClientId', xClientId)
            // verify required parameter 'inspectionId' is not null or undefined
            assertParamExists('updateInspection', 'inspectionId', inspectionId)
            // verify required parameter 'inspection' is not null or undefined
            assertParamExists('updateInspection', 'inspection', inspection)
            const localVarPath = `/v1/sessions/inspection/update/{inspectionId}`
                .replace(`{${"inspectionId"}}`, encodeURIComponent(String(inspectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(inspection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} jobId runId of inference pipeline
         * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrainingStatus: async (xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateTrainingStatus', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateTrainingStatus', 'jobId', jobId)
            // verify required parameter 'jobStatus' is not null or undefined
            assertParamExists('updateTrainingStatus', 'jobStatus', jobStatus)
            const localVarPath = `/v1/training/job/update/status/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jobStatus !== undefined) {
                localVarQueryParameter['jobStatus'] = jobStatus;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * adding new inspection (page) to a session
         * @summary add new inspection
         * @param {string} xClientId client ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewInspection(xClientId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewInspection(xClientId, inspection, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [xClientId] client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkActualInferenceStatus(referenceId: string, xClientId?: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkActualInferenceStatus(referenceId, xClientId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkInferenceStatus(xClientId: string, referenceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkInferenceStatus(xClientId, referenceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} referenceId runId of inference pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkV3InferenceStatus(xClientId: string, authorization: string, referenceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkV3InferenceStatus(xClientId, authorization, referenceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * adding new session to a job
         * @summary add new session
         * @param {string} xClientId client ID
         * @param {SessionRequest} sessionRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewSession(xClientId: string, sessionRequest: SessionRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewSession(xClientId, sessionRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * end a session after inspections
         * @summary end a session
         * @param {string} xClientId client ID
         * @param {SessionUpdateRequest} sessionUpdateRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endSession(xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endSession(xClientId, sessionUpdateRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary generate samples
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} xClientId client ID
         * @param {SampleGenerationRequest} sampleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSamples(authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SampleGenerationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSamples(authorization, xClientId, sampleGenerationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all inspected results of a single session
         * @summary Get all inspected results
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {GetInferenceResultRequest} getInferenceResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInferenceResult(xClientId: string, authorization: string, getInferenceResultRequest: GetInferenceResultRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInferenceResult(xClientId, authorization, getInferenceResultRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * inspection result for sample before the approval
         * @summary get SAMPLE inspection result
         * @param {string} xClientId client ID
         * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSampleInspectionResult(xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSampleInspectionResult(xClientId, sampleSessionSearchRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateInference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateInference(xClientId, authorization, inferenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {InferenceRequest} inferenceRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateRealInference(xClientId: string, inferenceRequest: InferenceRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateRealInference(xClientId, inferenceRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateV3Inference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateV3Inference(xClientId, authorization, inferenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * search sessions for given search criteria
         * @summary search sessions
         * @param {string} xClientId client ID
         * @param {SessionSearchRequest} sessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSessions(xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSessions(xClientId, sessionSearchRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update inspection with a result
         * @summary update inspection
         * @param {string} xClientId client ID
         * @param {string} inspectionId inspection ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInspection(xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInspection(xClientId, inspectionId, inspection, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} jobId runId of inference pipeline
         * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrainingStatus(xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrainingStatus(xClientId, jobId, jobStatus, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * adding new inspection (page) to a session
         * @summary add new inspection
         * @param {string} xClientId client ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewInspection(xClientId: string, inspection: Inspection, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addNewInspection(xClientId, inspection, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [xClientId] client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActualInferenceStatus(referenceId: string, xClientId?: string, authorization?: string, options?: any): AxiosPromise<Inference> {
            return localVarFp.checkActualInferenceStatus(referenceId, xClientId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} referenceId runId of inference pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInferenceStatus(xClientId: string, referenceId: string, authorization?: string, options?: any): AxiosPromise<Inference> {
            return localVarFp.checkInferenceStatus(xClientId, referenceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} referenceId runId of inference pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkV3InferenceStatus(xClientId: string, authorization: string, referenceId: string, options?: any): AxiosPromise<Inference> {
            return localVarFp.checkV3InferenceStatus(xClientId, authorization, referenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * adding new session to a job
         * @summary add new session
         * @param {string} xClientId client ID
         * @param {SessionRequest} sessionRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSession(xClientId: string, sessionRequest: SessionRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.createNewSession(xClientId, sessionRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * end a session after inspections
         * @summary end a session
         * @param {string} xClientId client ID
         * @param {SessionUpdateRequest} sessionUpdateRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endSession(xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.endSession(xClientId, sessionUpdateRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary generate samples
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} xClientId client ID
         * @param {SampleGenerationRequest} sampleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSamples(authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options?: any): AxiosPromise<SampleGenerationResponse> {
            return localVarFp.generateSamples(authorization, xClientId, sampleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all inspected results of a single session
         * @summary Get all inspected results
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {GetInferenceResultRequest} getInferenceResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResult(xClientId: string, authorization: string, getInferenceResultRequest: GetInferenceResultRequest, options?: any): AxiosPromise<Session> {
            return localVarFp.getInferenceResult(xClientId, authorization, getInferenceResultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * inspection result for sample before the approval
         * @summary get SAMPLE inspection result
         * @param {string} xClientId client ID
         * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleInspectionResult(xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSampleInspectionResult(xClientId, sampleSessionSearchRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateInference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: any): AxiosPromise<PipelineTriggerResponse> {
            return localVarFp.initiateInference(xClientId, authorization, inferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {InferenceRequest} inferenceRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRealInference(xClientId: string, inferenceRequest: InferenceRequest, authorization?: string, options?: any): AxiosPromise<PipelineTriggerResponse> {
            return localVarFp.initiateRealInference(xClientId, inferenceRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inspect the sample against the trained AI model
         * @param {string} xClientId client ID
         * @param {string} authorization Bearer Token for Authorization
         * @param {InferenceRequest} inferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateV3Inference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: any): AxiosPromise<PipelineTriggerResponse> {
            return localVarFp.initiateV3Inference(xClientId, authorization, inferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * search sessions for given search criteria
         * @summary search sessions
         * @param {string} xClientId client ID
         * @param {SessionSearchRequest} sessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSessions(xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options?: any): AxiosPromise<SessionSearchResponse> {
            return localVarFp.searchSessions(xClientId, sessionSearchRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * update inspection with a result
         * @summary update inspection
         * @param {string} xClientId client ID
         * @param {string} inspectionId inspection ID
         * @param {Inspection} inspection 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInspection(xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateInspection(xClientId, inspectionId, inspection, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} jobId runId of inference pipeline
         * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrainingStatus(xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateTrainingStatus(xClientId, jobId, jobStatus, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * adding new inspection (page) to a session
     * @summary add new inspection
     * @param {string} xClientId client ID
     * @param {Inspection} inspection 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public addNewInspection(xClientId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).addNewInspection(xClientId, inspection, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary check the Inference status
     * @param {string} referenceId runId of inference pipeline
     * @param {string} [xClientId] client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public checkActualInferenceStatus(referenceId: string, xClientId?: string, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).checkActualInferenceStatus(referenceId, xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary check the Inference status
     * @param {string} xClientId client ID
     * @param {string} referenceId runId of inference pipeline
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public checkInferenceStatus(xClientId: string, referenceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).checkInferenceStatus(xClientId, referenceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary check the Inference status
     * @param {string} xClientId client ID
     * @param {string} authorization Bearer Token for Authorization
     * @param {string} referenceId runId of inference pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public checkV3InferenceStatus(xClientId: string, authorization: string, referenceId: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).checkV3InferenceStatus(xClientId, authorization, referenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * adding new session to a job
     * @summary add new session
     * @param {string} xClientId client ID
     * @param {SessionRequest} sessionRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public createNewSession(xClientId: string, sessionRequest: SessionRequest, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).createNewSession(xClientId, sessionRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * end a session after inspections
     * @summary end a session
     * @param {string} xClientId client ID
     * @param {SessionUpdateRequest} sessionUpdateRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public endSession(xClientId: string, sessionUpdateRequest: SessionUpdateRequest, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).endSession(xClientId, sessionUpdateRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary generate samples
     * @param {string} authorization Bearer Token for Authorization
     * @param {string} xClientId client ID
     * @param {SampleGenerationRequest} sampleGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public generateSamples(authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).generateSamples(authorization, xClientId, sampleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all inspected results of a single session
     * @summary Get all inspected results
     * @param {string} xClientId client ID
     * @param {string} authorization Bearer Token for Authorization
     * @param {GetInferenceResultRequest} getInferenceResultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getInferenceResult(xClientId: string, authorization: string, getInferenceResultRequest: GetInferenceResultRequest, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getInferenceResult(xClientId, authorization, getInferenceResultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * inspection result for sample before the approval
     * @summary get SAMPLE inspection result
     * @param {string} xClientId client ID
     * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSampleInspectionResult(xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getSampleInspectionResult(xClientId, sampleSessionSearchRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inspect the sample against the trained AI model
     * @param {string} xClientId client ID
     * @param {string} authorization Bearer Token for Authorization
     * @param {InferenceRequest} inferenceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public initiateInference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).initiateInference(xClientId, authorization, inferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inspect the sample against the trained AI model
     * @param {string} xClientId client ID
     * @param {InferenceRequest} inferenceRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public initiateRealInference(xClientId: string, inferenceRequest: InferenceRequest, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).initiateRealInference(xClientId, inferenceRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inspect the sample against the trained AI model
     * @param {string} xClientId client ID
     * @param {string} authorization Bearer Token for Authorization
     * @param {InferenceRequest} inferenceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public initiateV3Inference(xClientId: string, authorization: string, inferenceRequest: InferenceRequest, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).initiateV3Inference(xClientId, authorization, inferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * search sessions for given search criteria
     * @summary search sessions
     * @param {string} xClientId client ID
     * @param {SessionSearchRequest} sessionSearchRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public searchSessions(xClientId: string, sessionSearchRequest: SessionSearchRequest, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).searchSessions(xClientId, sessionSearchRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update inspection with a result
     * @summary update inspection
     * @param {string} xClientId client ID
     * @param {string} inspectionId inspection ID
     * @param {Inspection} inspection 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public updateInspection(xClientId: string, inspectionId: string, inspection: Inspection, authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).updateInspection(xClientId, inspectionId, inspection, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary check the Inference status
     * @param {string} xClientId client ID
     * @param {string} jobId runId of inference pipeline
     * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public updateTrainingStatus(xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).updateTrainingStatus(xClientId, jobId, jobStatus, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterData: async (xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addMasterData', 'xClientId', xClientId)
            const localVarPath = `/v1/tenant/training/msdata/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addMasterDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTenant: async (xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addTenant', 'xClientId', xClientId)
            const localVarPath = `/v1/tenant/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addTenantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterData: async (xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getMasterData', 'xClientId', xClientId)
            // verify required parameter 'mtype' is not null or undefined
            assertParamExists('getMasterData', 'mtype', mtype)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMasterData', 'tenantId', tenantId)
            const localVarPath = `/v1/tenant/training/msdata/{mtype}`
                .replace(`{${"mtype"}}`, encodeURIComponent(String(mtype)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantApiAxiosParamCreator(configuration)
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMasterData(xClientId, authorization, addMasterDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTenant(xClientId, authorization, addTenantRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResposne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMasterData(xClientId, mtype, tenantId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantApiFp(configuration)
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addMasterData(xClientId, authorization, addMasterDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addTenant(xClientId, authorization, addTenantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: any): AxiosPromise<DataResposne> {
            return localVarFp.getMasterData(xClientId, mtype, tenantId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * add master data
     * @summary add master data
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {AddMasterDataRequest} [addMasterDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).addMasterData(xClientId, authorization, addMasterDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add tenant
     * @summary add tenant
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {AddTenantRequest} [addTenantRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).addTenant(xClientId, authorization, addTenantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary get master data
     * @param {string} xClientId client ID
     * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
     * @param {number} tenantId tenantId
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getMasterData(xClientId, mtype, tenantId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrainingJobApi - axios parameter creator
 * @export
 */
export const TrainingJobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} xClientId client ID
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrainingJob: async (xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addTrainingJob', 'xClientId', xClientId)
            // verify required parameter 'addJobRequest' is not null or undefined
            assertParamExists('addTrainingJob', 'addJobRequest', addJobRequest)
            const localVarPath = `/v1/training/job/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel the process
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTraining: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('cancelTraining', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cancelTraining', 'jobId', jobId)
            const localVarPath = `/v1/training/job/ai/cancel/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user
         * @summary Delete a job
         * @param {string} xClientId client ID
         * @param {string} jobId The job that needs to be deleted
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('deleteJobById', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobById', 'jobId', jobId)
            const localVarPath = `/v1/training/job/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary download samples
         * @param {string} xClientId client ID
         * @param {SamplesRequest} samplesRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSamples: async (xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('downloadSamples', 'xClientId', xClientId)
            // verify required parameter 'samplesRequest' is not null or undefined
            assertParamExists('downloadSamples', 'samplesRequest', samplesRequest)
            const localVarPath = `/v1/training/job/generate/samples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(samplesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getJobById', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobById', 'jobId', jobId)
            const localVarPath = `/v1/training/job/view/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobs: async (xClientId: string, authorization?: string, searchRequest?: SearchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('searchJobs', 'xClientId', xClientId)
            const localVarPath = `/v1/training/jobs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentArtwork: async (xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('segmentArtwork', 'xClientId', xClientId)
            const localVarPath = `/v1/training/job/artwork/segment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(segmentArtworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AI processes the label and start training the model
         * @param {string} jobId ID of job to process
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTraining: async (jobId: string, xClientId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('startTraining', 'jobId', jobId)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('startTraining', 'xClientId', xClientId)
            const localVarPath = `/v1/training/job/ai/start/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Results will be different by product or based on roles of the current logged in user
         * @summary Job status summary in landing page
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingJobsSummary: async (xClientId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('trainingJobsSummary', 'xClientId', xClientId)
            const localVarPath = `/v1/training/jobs/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary check training status of the model
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingStatus: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('trainingStatus', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('trainingStatus', 'jobId', jobId)
            const localVarPath = `/v1/training/job/ai/status/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update the job details
         * @summary update the job details
         * @param {string} xClientId client ID
         * @param {string} referenceId jobId
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobById: async (xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateJobById', 'xClientId', xClientId)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('updateJobById', 'referenceId', referenceId)
            // verify required parameter 'addJobRequest' is not null or undefined
            assertParamExists('updateJobById', 'addJobRequest', addJobRequest)
            const localVarPath = `/v1/training/job/update/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainingJobApi - functional programming interface
 * @export
 */
export const TrainingJobApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TrainingJobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} xClientId client ID
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTrainingJob(xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTrainingJob(xClientId, addJobRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel the process
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTraining(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTraining(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This can only be done by the logged in user
         * @summary Delete a job
         * @param {string} xClientId client ID
         * @param {string} jobId The job that needs to be deleted
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobById(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary download samples
         * @param {string} xClientId client ID
         * @param {SamplesRequest} samplesRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSamples(xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSamples(xClientId, samplesRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobById(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchJobs(xClientId, authorization, searchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentArtwork(xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segementations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentArtwork(xClientId, authorization, segmentArtworkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary AI processes the label and start training the model
         * @param {string} jobId ID of job to process
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTraining(jobId: string, xClientId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTraining(jobId, xClientId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Results will be different by product or based on roles of the current logged in user
         * @summary Job status summary in landing page
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingJobsSummary(xClientId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Summary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingJobsSummary(xClientId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary check training status of the model
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingStatus(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingStatus(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update the job details
         * @summary update the job details
         * @param {string} xClientId client ID
         * @param {string} referenceId jobId
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobById(xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobById(xClientId, referenceId, addJobRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrainingJobApi - factory interface
 * @export
 */
export const TrainingJobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrainingJobApiFp(configuration)
    return {
        /**
         * 
         * @param {string} xClientId client ID
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrainingJob(xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addTrainingJob(xClientId, addJobRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel the process
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTraining(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.cancelTraining(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user
         * @summary Delete a job
         * @param {string} xClientId client ID
         * @param {string} jobId The job that needs to be deleted
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.deleteJobById(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary download samples
         * @param {string} xClientId client ID
         * @param {SamplesRequest} samplesRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSamples(xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.downloadSamples(xClientId, samplesRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<Job> {
            return localVarFp.getJobById(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: any): AxiosPromise<SearchResponse> {
            return localVarFp.searchJobs(xClientId, authorization, searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentArtwork(xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options?: any): AxiosPromise<Segementations> {
            return localVarFp.segmentArtwork(xClientId, authorization, segmentArtworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AI processes the label and start training the model
         * @param {string} jobId ID of job to process
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTraining(jobId: string, xClientId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.startTraining(jobId, xClientId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Results will be different by product or based on roles of the current logged in user
         * @summary Job status summary in landing page
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingJobsSummary(xClientId: string, authorization?: string, options?: any): AxiosPromise<Summary> {
            return localVarFp.trainingJobsSummary(xClientId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary check training status of the model
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingStatus(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.trainingStatus(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * update the job details
         * @summary update the job details
         * @param {string} xClientId client ID
         * @param {string} referenceId jobId
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobById(xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateJobById(xClientId, referenceId, addJobRequest, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrainingJobApi - object-oriented interface
 * @export
 * @class TrainingJobApi
 * @extends {BaseAPI}
 */
export class TrainingJobApi extends BaseAPI {
    /**
     * 
     * @param {string} xClientId client ID
     * @param {AddJobRequest} addJobRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public addTrainingJob(xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).addTrainingJob(xClientId, addJobRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel the process
     * @param {string} xClientId client ID
     * @param {string} jobId ID of pipeline
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public cancelTraining(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).cancelTraining(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This can only be done by the logged in user
     * @summary Delete a job
     * @param {string} xClientId client ID
     * @param {string} jobId The job that needs to be deleted
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public deleteJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).deleteJobById(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary download samples
     * @param {string} xClientId client ID
     * @param {SamplesRequest} samplesRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public downloadSamples(xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).downloadSamples(xClientId, samplesRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} jobId jobId
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public getJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).getJobById(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * paginated API ,call this API in each tab
     * @summary Find jobs by status
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {SearchRequest} [searchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).searchJobs(xClientId, authorization, searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public segmentArtwork(xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).segmentArtwork(xClientId, authorization, segmentArtworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AI processes the label and start training the model
     * @param {string} jobId ID of job to process
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public startTraining(jobId: string, xClientId: string, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).startTraining(jobId, xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Results will be different by product or based on roles of the current logged in user
     * @summary Job status summary in landing page
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public trainingJobsSummary(xClientId: string, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).trainingJobsSummary(xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary check training status of the model
     * @param {string} xClientId client ID
     * @param {string} jobId ID of pipeline
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public trainingStatus(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).trainingStatus(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update the job details
     * @summary update the job details
     * @param {string} xClientId client ID
     * @param {string} referenceId jobId
     * @param {AddJobRequest} addJobRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingJobApi
     */
    public updateJobById(xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig) {
        return TrainingJobApiFp(this.configuration).updateJobById(xClientId, referenceId, addJobRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebApi - axios parameter creator
 * @export
 */
export const WebApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterData: async (xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addMasterData', 'xClientId', xClientId)
            const localVarPath = `/v1/tenant/training/msdata/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addMasterDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTenant: async (xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addTenant', 'xClientId', xClientId)
            const localVarPath = `/v1/tenant/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addTenantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrainingJob: async (xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('addTrainingJob', 'xClientId', xClientId)
            // verify required parameter 'addJobRequest' is not null or undefined
            assertParamExists('addTrainingJob', 'addJobRequest', addJobRequest)
            const localVarPath = `/v1/training/job/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel the process
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTraining: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('cancelTraining', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cancelTraining', 'jobId', jobId)
            const localVarPath = `/v1/training/job/ai/cancel/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('deleteFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('deleteFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user
         * @summary Delete a job
         * @param {string} xClientId client ID
         * @param {string} jobId The job that needs to be deleted
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('deleteJobById', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJobById', 'jobId', jobId)
            const localVarPath = `/v1/training/job/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('downloadFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('downloadFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary download samples
         * @param {string} xClientId client ID
         * @param {SamplesRequest} samplesRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSamples: async (xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('downloadSamples', 'xClientId', xClientId)
            // verify required parameter 'samplesRequest' is not null or undefined
            assertParamExists('downloadSamples', 'samplesRequest', samplesRequest)
            const localVarPath = `/v1/training/job/generate/samples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(samplesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary generate samples
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} xClientId client ID
         * @param {SampleGenerationRequest} sampleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSamples: async (authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('generateSamples', 'authorization', authorization)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('generateSamples', 'xClientId', xClientId)
            // verify required parameter 'sampleGenerationRequest' is not null or undefined
            assertParamExists('generateSamples', 'sampleGenerationRequest', sampleGenerationRequest)
            const localVarPath = `/v1/sessions/generate/samples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sampleGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getJobById', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobById', 'jobId', jobId)
            const localVarPath = `/v1/training/job/view/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterData: async (xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getMasterData', 'xClientId', xClientId)
            // verify required parameter 'mtype' is not null or undefined
            assertParamExists('getMasterData', 'mtype', mtype)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMasterData', 'tenantId', tenantId)
            const localVarPath = `/v1/tenant/training/msdata/{mtype}`
                .replace(`{${"mtype"}}`, encodeURIComponent(String(mtype)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * inspection result for sample before the approval
         * @summary get SAMPLE inspection result
         * @param {string} xClientId client ID
         * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleInspectionResult: async (xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('getSampleInspectionResult', 'xClientId', xClientId)
            // verify required parameter 'sampleSessionSearchRequest' is not null or undefined
            assertParamExists('getSampleInspectionResult', 'sampleSessionSearchRequest', sampleSessionSearchRequest)
            const localVarPath = `/v1/sessions/sample/inspections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sampleSessionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobs: async (xClientId: string, authorization?: string, searchRequest?: SearchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('searchJobs', 'xClientId', xClientId)
            const localVarPath = `/v1/training/jobs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentArtwork: async (xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('segmentArtwork', 'xClientId', xClientId)
            const localVarPath = `/v1/training/job/artwork/segment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(segmentArtworkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AI processes the label and start training the model
         * @param {string} jobId ID of job to process
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTraining: async (jobId: string, xClientId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('startTraining', 'jobId', jobId)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('startTraining', 'xClientId', xClientId)
            const localVarPath = `/v1/training/job/ai/start/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Results will be different by product or based on roles of the current logged in user
         * @summary Job status summary in landing page
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingJobsSummary: async (xClientId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('trainingJobsSummary', 'xClientId', xClientId)
            const localVarPath = `/v1/training/jobs/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary check training status of the model
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingStatus: async (xClientId: string, jobId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('trainingStatus', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('trainingStatus', 'jobId', jobId)
            const localVarPath = `/v1/training/job/ai/status/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {File} [file] 
         * @param {string} [fileType] 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile: async (xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('updateFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }

            if (fileType !== undefined) {
                localVarFormParams.append('fileType', fileType as any);
            }

            if (resourceName !== undefined) {
                localVarFormParams.append('resourceName', resourceName as any);
            }

            if (resourceId !== undefined) {
                localVarFormParams.append('resourceId', resourceId as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update the job details
         * @summary update the job details
         * @param {string} xClientId client ID
         * @param {string} referenceId jobId
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobById: async (xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateJobById', 'xClientId', xClientId)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('updateJobById', 'referenceId', referenceId)
            // verify required parameter 'addJobRequest' is not null or undefined
            assertParamExists('updateJobById', 'addJobRequest', addJobRequest)
            const localVarPath = `/v1/training/job/update/{referenceId}`
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} jobId runId of inference pipeline
         * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrainingStatus: async (xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('updateTrainingStatus', 'xClientId', xClientId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('updateTrainingStatus', 'jobId', jobId)
            // verify required parameter 'jobStatus' is not null or undefined
            assertParamExists('updateTrainingStatus', 'jobStatus', jobStatus)
            const localVarPath = `/v1/training/job/update/status/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (jobStatus !== undefined) {
                localVarQueryParameter['jobStatus'] = jobStatus;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('uploadFile', 'xClientId', xClientId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFile', 'file', file)
            // verify required parameter 'resourceName' is not null or undefined
            assertParamExists('uploadFile', 'resourceName', resourceName)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('uploadFile', 'fileType', fileType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('uploadFile', 'clientId', clientId)
            // verify required parameter 'uploadedDevice' is not null or undefined
            assertParamExists('uploadFile', 'uploadedDevice', uploadedDevice)
            const localVarPath = `/v1/resources/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }


            if (file !== undefined) {
                localVarFormParams.append('file', file as any);
            }

            if (resourceName !== undefined) {
                localVarFormParams.append('resourceName', resourceName as any);
            }

            if (fileType !== undefined) {
                localVarFormParams.append('fileType', fileType as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.append('clientId', clientId as any);
            }

            if (uploadedDevice !== undefined) {
                localVarFormParams.append('uploadedDevice', uploadedDevice as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile: async (xClientId: string, resourceId: string, authorization?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('viewFile', 'xClientId', xClientId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('viewFile', 'resourceId', resourceId)
            const localVarPath = `/v1/resources/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebApi - functional programming interface
 * @export
 */
export const WebApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = WebApiAxiosParamCreator(configuration)
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMasterData(xClientId, authorization, addMasterDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTenant(xClientId, authorization, addTenantRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTrainingJob(xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTrainingJob(xClientId, addJobRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel the process
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTraining(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTraining(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This can only be done by the logged in user
         * @summary Delete a job
         * @param {string} xClientId client ID
         * @param {string} jobId The job that needs to be deleted
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJobById(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary download samples
         * @param {string} xClientId client ID
         * @param {SamplesRequest} samplesRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSamples(xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSamples(xClientId, samplesRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary generate samples
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} xClientId client ID
         * @param {SampleGenerationRequest} sampleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSamples(authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SampleGenerationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSamples(authorization, xClientId, sampleGenerationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobById(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResposne>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMasterData(xClientId, mtype, tenantId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * inspection result for sample before the approval
         * @summary get SAMPLE inspection result
         * @param {string} xClientId client ID
         * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSampleInspectionResult(xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSampleInspectionResult(xClientId, sampleSessionSearchRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchJobs(xClientId, authorization, searchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentArtwork(xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segementations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentArtwork(xClientId, authorization, segmentArtworkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary AI processes the label and start training the model
         * @param {string} jobId ID of job to process
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTraining(jobId: string, xClientId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTraining(jobId, xClientId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Results will be different by product or based on roles of the current logged in user
         * @summary Job status summary in landing page
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingJobsSummary(xClientId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Summary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingJobsSummary(xClientId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary check training status of the model
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingStatus(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingStatus(xClientId, jobId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {File} [file] 
         * @param {string} [fileType] 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFile(xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFile(xClientId, resourceId, authorization, file, fileType, resourceName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update the job details
         * @summary update the job details
         * @param {string} xClientId client ID
         * @param {string} referenceId jobId
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJobById(xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJobById(xClientId, referenceId, addJobRequest, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} jobId runId of inference pipeline
         * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrainingStatus(xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrainingStatus(xClientId, jobId, jobStatus, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewFile(xClientId, resourceId, authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebApi - factory interface
 * @export
 */
export const WebApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebApiFp(configuration)
    return {
        /**
         * add master data
         * @summary add master data
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddMasterDataRequest} [addMasterDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addMasterData(xClientId, authorization, addMasterDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * add tenant
         * @summary add tenant
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {AddTenantRequest} [addTenantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addTenant(xClientId, authorization, addTenantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTrainingJob(xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.addTrainingJob(xClientId, addJobRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel the process
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTraining(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.cancelTraining(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<DeleteFileResponse> {
            return localVarFp.deleteFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user
         * @summary Delete a job
         * @param {string} xClientId client ID
         * @param {string} jobId The job that needs to be deleted
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJobById(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.deleteJobById(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary download samples
         * @param {string} xClientId client ID
         * @param {SamplesRequest} samplesRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSamples(xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.downloadSamples(xClientId, samplesRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary generate samples
         * @param {string} authorization Bearer Token for Authorization
         * @param {string} xClientId client ID
         * @param {SampleGenerationRequest} sampleGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSamples(authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options?: any): AxiosPromise<SampleGenerationResponse> {
            return localVarFp.generateSamples(authorization, xClientId, sampleGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} jobId jobId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobById(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<Job> {
            return localVarFp.getJobById(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary get master data
         * @param {string} xClientId client ID
         * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
         * @param {number} tenantId tenantId
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: any): AxiosPromise<DataResposne> {
            return localVarFp.getMasterData(xClientId, mtype, tenantId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * inspection result for sample before the approval
         * @summary get SAMPLE inspection result
         * @param {string} xClientId client ID
         * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSampleInspectionResult(xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.getSampleInspectionResult(xClientId, sampleSessionSearchRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * paginated API ,call this API in each tab
         * @summary Find jobs by status
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SearchRequest} [searchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: any): AxiosPromise<SearchResponse> {
            return localVarFp.searchJobs(xClientId, authorization, searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentArtwork(xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options?: any): AxiosPromise<Segementations> {
            return localVarFp.segmentArtwork(xClientId, authorization, segmentArtworkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AI processes the label and start training the model
         * @param {string} jobId ID of job to process
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTraining(jobId: string, xClientId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.startTraining(jobId, xClientId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Results will be different by product or based on roles of the current logged in user
         * @summary Job status summary in landing page
         * @param {string} xClientId client ID
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingJobsSummary(xClientId: string, authorization?: string, options?: any): AxiosPromise<Summary> {
            return localVarFp.trainingJobsSummary(xClientId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary check training status of the model
         * @param {string} xClientId client ID
         * @param {string} jobId ID of pipeline
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingStatus(xClientId: string, jobId: string, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.trainingStatus(xClientId, jobId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {File} [file] 
         * @param {string} [fileType] 
         * @param {string} [resourceName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFile(xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options?: any): AxiosPromise<FileUpdateResponse> {
            return localVarFp.updateFile(xClientId, resourceId, authorization, file, fileType, resourceName, options).then((request) => request(axios, basePath));
        },
        /**
         * update the job details
         * @summary update the job details
         * @param {string} xClientId client ID
         * @param {string} referenceId jobId
         * @param {AddJobRequest} addJobRequest 
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJobById(xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateJobById(xClientId, referenceId, addJobRequest, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * polling API untill you get the final result
         * @summary check the Inference status
         * @param {string} xClientId client ID
         * @param {string} jobId runId of inference pipeline
         * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
         * @param {string} [authorization] Bearer Token for Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrainingStatus(xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.updateTrainingStatus(xClientId, jobId, jobStatus, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId client ID
         * @param {File} file 
         * @param {string} resourceName 
         * @param {string} fileType 
         * @param {string} clientId 
         * @param {string} uploadedDevice 
         * @param {string} [authorization] Authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: any): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} xClientId Client id
         * @param {string} resourceId 
         * @param {string} [authorization] Bearer Authorization token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewFile(xClientId: string, resourceId: string, authorization?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.viewFile(xClientId, resourceId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebApi - object-oriented interface
 * @export
 * @class WebApi
 * @extends {BaseAPI}
 */
export class WebApi extends BaseAPI {
    /**
     * add master data
     * @summary add master data
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {AddMasterDataRequest} [addMasterDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public addMasterData(xClientId: string, authorization?: string, addMasterDataRequest?: AddMasterDataRequest, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).addMasterData(xClientId, authorization, addMasterDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add tenant
     * @summary add tenant
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {AddTenantRequest} [addTenantRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public addTenant(xClientId: string, authorization?: string, addTenantRequest?: AddTenantRequest, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).addTenant(xClientId, authorization, addTenantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {AddJobRequest} addJobRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public addTrainingJob(xClientId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).addTrainingJob(xClientId, addJobRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel the process
     * @param {string} xClientId client ID
     * @param {string} jobId ID of pipeline
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public cancelTraining(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).cancelTraining(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public deleteFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).deleteFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This can only be done by the logged in user
     * @summary Delete a job
     * @param {string} xClientId client ID
     * @param {string} jobId The job that needs to be deleted
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public deleteJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).deleteJobById(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId Client id
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public downloadFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).downloadFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary download samples
     * @param {string} xClientId client ID
     * @param {SamplesRequest} samplesRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public downloadSamples(xClientId: string, samplesRequest: SamplesRequest, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).downloadSamples(xClientId, samplesRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary generate samples
     * @param {string} authorization Bearer Token for Authorization
     * @param {string} xClientId client ID
     * @param {SampleGenerationRequest} sampleGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public generateSamples(authorization: string, xClientId: string, sampleGenerationRequest: SampleGenerationRequest, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).generateSamples(authorization, xClientId, sampleGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} jobId jobId
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public getJobById(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).getJobById(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary get master data
     * @param {string} xClientId client ID
     * @param {'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes'} mtype masterdata type of a tenant
     * @param {number} tenantId tenantId
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public getMasterData(xClientId: string, mtype: 'buyers' | 'labelCategories' | 'qcStations' | 'qcTypes', tenantId: number, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).getMasterData(xClientId, mtype, tenantId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * inspection result for sample before the approval
     * @summary get SAMPLE inspection result
     * @param {string} xClientId client ID
     * @param {SampleSessionSearchRequest} sampleSessionSearchRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public getSampleInspectionResult(xClientId: string, sampleSessionSearchRequest: SampleSessionSearchRequest, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).getSampleInspectionResult(xClientId, sampleSessionSearchRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * paginated API ,call this API in each tab
     * @summary Find jobs by status
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {SearchRequest} [searchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public searchJobs(xClientId: string, authorization?: string, searchRequest?: SearchRequest, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).searchJobs(xClientId, authorization, searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {SegmentArtworkRequest} [segmentArtworkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public segmentArtwork(xClientId: string, authorization?: string, segmentArtworkRequest?: SegmentArtworkRequest, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).segmentArtwork(xClientId, authorization, segmentArtworkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AI processes the label and start training the model
     * @param {string} jobId ID of job to process
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public startTraining(jobId: string, xClientId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).startTraining(jobId, xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Results will be different by product or based on roles of the current logged in user
     * @summary Job status summary in landing page
     * @param {string} xClientId client ID
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public trainingJobsSummary(xClientId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).trainingJobsSummary(xClientId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary check training status of the model
     * @param {string} xClientId client ID
     * @param {string} jobId ID of pipeline
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public trainingStatus(xClientId: string, jobId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).trainingStatus(xClientId, jobId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {File} [file] 
     * @param {string} [fileType] 
     * @param {string} [resourceName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public updateFile(xClientId: string, resourceId: string, authorization?: string, file?: File, fileType?: string, resourceName?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).updateFile(xClientId, resourceId, authorization, file, fileType, resourceName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update the job details
     * @summary update the job details
     * @param {string} xClientId client ID
     * @param {string} referenceId jobId
     * @param {AddJobRequest} addJobRequest 
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public updateJobById(xClientId: string, referenceId: string, addJobRequest: AddJobRequest, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).updateJobById(xClientId, referenceId, addJobRequest, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * polling API untill you get the final result
     * @summary check the Inference status
     * @param {string} xClientId client ID
     * @param {string} jobId runId of inference pipeline
     * @param {'APPROVED' | 'REJECTED'} jobStatus jobstatus update with user interactions
     * @param {string} [authorization] Bearer Token for Authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public updateTrainingStatus(xClientId: string, jobId: string, jobStatus: 'APPROVED' | 'REJECTED', authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).updateTrainingStatus(xClientId, jobId, jobStatus, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId client ID
     * @param {File} file 
     * @param {string} resourceName 
     * @param {string} fileType 
     * @param {string} clientId 
     * @param {string} uploadedDevice 
     * @param {string} [authorization] Authorization Bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public uploadFile(xClientId: string, file: File, resourceName: string, fileType: string, clientId: string, uploadedDevice: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).uploadFile(xClientId, file, resourceName, fileType, clientId, uploadedDevice, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} xClientId Client id
     * @param {string} resourceId 
     * @param {string} [authorization] Bearer Authorization token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebApi
     */
    public viewFile(xClientId: string, resourceId: string, authorization?: string, options?: AxiosRequestConfig) {
        return WebApiFp(this.configuration).viewFile(xClientId, resourceId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}


